#!/usr/bin/env python3

import collections
from contextlib import contextmanager
from functools import partial, wraps
from optparse import OptionParser
import os
import os.path
import platform
import subprocess
import string
import sys
import time


################################################################################
#
# Shared configuration
#
################################################################################


xcrun = '/usr/bin/xcrun'

mw_version = 'CUSTOM'

srcroot = os.path.abspath((os.path.dirname(__file__) or '.') + '/..')


################################################################################
#
# Build helpers
#
################################################################################


class BuilderSkipped(Exception):
    pass


def announce(msg, *args):
    sys.stderr.write((msg + '\n') % args)
    sys.stderr.flush()


did_warn = False

def warn(msg, *args):
    global did_warn
    announce('WARNING: ' + msg, *args)
    did_warn = True


def check_call(args, **kwargs):
    announce('Running command: %s', ' '.join(repr(a) for a in args))
    subprocess.check_call(args, **kwargs)


@contextmanager
def workdir(path):
    old_path = os.getcwd()
    announce('Entering directory %r', path)
    os.chdir(path)

    try:
        yield
    except BuilderSkipped:
        skipped = True
    else:
        skipped = False

    announce('Leaving directory %r', path)
    os.chdir(old_path)
    if skipped:
        raise BuilderSkipped


all_builders = collections.OrderedDict()
required_builder_names = []

def builder(func, *, build_dir=None, name=None, required=False):
    if isinstance(func, str):
        return partial(builder,
                       build_dir = func,
                       name = name,
                       required = required)

    if build_dir is None:
        build_dir = func.__name__
    if name is None:
        name = func.__name__

    @wraps(func)
    def func_wrapper():
        announce('Building %s', name)
        with workdir(build_dir):
            func()

    all_builders[name] = func_wrapper
    if required:
        required_builder_names.append(name)


def subdir_builder(func, *, base_dir=None, name=None):
    if isinstance(func, str):
        return partial(subdir_builder,
                       base_dir = func,
                       name = name)

    if base_dir is None:
        base_dir = func.__name__
    if name is None:
        name = func.__name__

    @wraps(func)
    def func_wrapper():
        if os.listdir():
            func()
        else:
            # An empty subdirectory is most likely a git submodule that hasn't
            # been initialized and/or updated.  Warn the user, in case this
            # isn't intentional.
            warn('Directory %r is empty; skipping current builder', os.getcwd())
            raise BuilderSkipped

    base_dir_path = os.path.join(srcroot, base_dir)
    for subdir in sorted(os.listdir(base_dir_path)):
        subdir_path = os.path.join(base_dir_path, subdir)
        if os.path.isdir(subdir_path) and (not subdir.startswith('.')):
            builder(func_wrapper,
                    build_dir = os.path.join(base_dir, subdir),
                    name = name + '/' + subdir)


def xcodebuild(scheme = 'Everything',
               destination = 'generic/platform=macOS,name=Any Mac',
               actions = ['clean', 'build']):
    cmd = [xcrun,
           'xcodebuild',
           '-scheme', scheme,
           '-destination', destination,
           ] + actions + [
           'GCC_TREAT_WARNINGS_AS_ERRORS=YES',
           'MTL_TREAT_WARNINGS_AS_ERRORS=YES',
           'SWIFT_TREAT_WARNINGS_AS_ERRORS=YES',
           ]

    if mw_version[0] in string.digits:
        # Use version number only if it starts with a digit.  This
        # will exclude fake versions like "NIGHTLY" and "CUSTOM".
        cmd.append('MW_VERSION=' + mw_version)

    check_call(cmd)


def make(args=[]):
    check_call([xcrun, 'make'] + args)


################################################################################
#
# Builders
#
################################################################################


@builder('build')
def prepare():
    check_call(['./prepare_for_install'])


@builder('build/xcode', required=True)
def build_requirements():
    make()


@builder
def supporting_libs():
    xcodebuild()
    with workdir('scarab'):
        xcodebuild()


@builder
def core():
    xcodebuild()


# Install the standard examples *before* building plugins, since some plugins
# will install their own examples/tests
@builder
def examples():
    make()


@subdir_builder('plugins/core')
def core_plugins():
    xcodebuild()


@builder('tools/python')
def python_tools():
    xcodebuild()


@builder
def swift():
    xcodebuild(scheme = 'MWorksSwift',
               destination = 'platform=macOS,arch=' + platform.machine(),
               actions = ['clean', 'build-for-testing', 'test'])
    xcodebuild(actions=['build'])


@builder
def cocoa():
    xcodebuild()


@builder('apps/client')
def client():
    xcodebuild()


@subdir_builder('plugins/client')
def client_plugins():
    xcodebuild()


@builder('tools/matlab')
def matlab_tools():
    try:
        xcodebuild('MATLAB Install Check')
    except subprocess.CalledProcessError:
        warn('MATLAB install check failed; skipping matlab_tools')
        raise BuilderSkipped

    xcodebuild()
    with workdir('MATLABWindow'):
        xcodebuild()


@builder('apps/server')
def server():
    xcodebuild()


@builder
def doc():
    xcodebuild()


@builder
def mwel():
    xcodebuild()


################################################################################
#
# Main function
#
################################################################################


def main():
    global mw_version

    parser = OptionParser(usage='Usage: %prog [options] [builder_name ...]')
    parser.add_option('--mw-version',
                      dest = 'mw_version',
                      default = mw_version,
                      help = 'MWorks version number [default: %default]')
    parser.add_option('--start-with',
                      dest = 'first_builder',
                      metavar = 'BUILDER_NAME',
                      help = 'Start build from given builder')

    (options, requested_builders) = parser.parse_args()
    mw_version = options.mw_version

    all_builder_names = list(all_builders.keys())

    if options.first_builder:
        if requested_builders:
            parser.error('cannot specify builder names when using --start-with')
        first_builder = options.first_builder
        if first_builder not in all_builder_names:
            parser.error('unknown builder: ' + first_builder)
        requested_builders = \
            all_builder_names[all_builder_names.index(first_builder):]
    else:
        unknown_builders = [name for name in requested_builders
                            if (name not in all_builder_names)]
        if unknown_builders:
            parser.error('unknown builders: ' +
                         ', '.join(repr(name) for name in unknown_builders))

    skipped_builder_names = []

    with workdir(srcroot):
        for builder_name, builder in all_builders.items():
            if ((not requested_builders) or
                (builder_name in requested_builders) or
                (builder_name in required_builder_names)):

                try:
                    builder()
                except BuilderSkipped:
                    skipped_builder_names.append(builder_name)

    if skipped_builder_names:
        msg = '\nThe following builders were skipped:\n\n'
        for name in skipped_builder_names:
            msg += '    %s\n' % name
        announce(msg)

    if did_warn:
        # The Python interpreter will exit with status 1 if there's an exception
        # and 2 if there's an argument-parsing error.  Exit with status 3 to
        # indicate that we omitted warnings but didn't otherwise fail.
        sys.exit(3)


if __name__ == '__main__':
    main()
